<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Cabine Fotogr√°fica</title>
<style>

/* --- photobooth fullscreen & overlay styles (added) --- */
#preview {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
  background: #000;
}
#countdown {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  pointer-events: none;
  color: #fff;
  text-shadow: 0 6px 18px rgba(0,0,0,0.75);
  font-weight: 700;
  font-family: 'Arial Black', Arial, sans-serif;
  -webkit-user-select: none;
  user-select: none;
  transition: opacity 0.15s ease;
}
#freezePreview {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  background: rgba(0,0,0,0.85);
  z-index: 9998;
  display: none;
  align-items: center;
  justify-content: center;
}
#countdown.hidden { display: none; }

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  font-family: Arial, sans-serif;
  background: #000;
  color: #fff;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  touch-action: manipulation;
}
.screen {
  width: 100%;
  height: 100%;
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  padding: 20px;
}
#welcomeScreen {
  display: flex;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}
#startScreen {
  background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
}
#cameraScreen {
  background: #000;
}
#resultScreen {
  background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
}
h1 {
  font-size: 2.5em;
  margin-bottom: 20px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}
h2 {
  font-size: 2em;
  margin-bottom: 30px;
}
button {
  font-size: 1.5em;
  padding: 20px 40px;
  background: #fff;
  color: #333;
  border: none;
  border-radius: 50px;
  cursor: pointer;
  margin: 10px;
  font-weight: bold;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  transition: all 0.3s;
}
button:hover {
  transform: scale(1.05);
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
}
video {
  width: 100%;
  height: 100%;
  object-fit: cover;
  position: absolute;
  top: 0;
  left: 0;
}
canvas {
  display: none;
}
#countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8em;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 20px rgba(255,255,255,0.8);
  z-index: 100;
}
#photoCounter {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.5em;
  background: rgba(0,0,0,0.7);
  padding: 10px 20px;
  border-radius: 20px;
  z-index: 100;
}
#finalImage {
  max-width: 90%;
  max-height: 70%;
  border: 10px solid white;
  border-radius: 20px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  margin-bottom: 30px;
}
.thankYou {
  font-size: 3em;
  font-weight: bold;
  margin-top: 30px;
  animation: pulse 2s infinite;
}
.error {
  color: #ff4444;
  background: rgba(255,68,68,0.1);
  padding: 15px;
  border-radius: 10px;
  margin: 10px 0;
}
.connection-status {
  position: absolute;
  top: 10px;
  right: 10px;
  padding: 5px 10px;
  border-radius: 15px;
  font-size: 12px;
  z-index: 1000;
}
.connected { background: #28a745; }
.disconnected { background: #dc3545; }
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}
</style>
</head>
<body>
<!-- shutter sound and freeze preview (added) -->
<audio id="shutterAudio" src="clack.mp3" preload="auto"></audio>
<div id="freezePreview"><img id="freezeImg" src="" alt="Foto congelada" style="max-width:100%; max-height:100%; display:block; margin:auto;"/></div>

<!-- Status da Conex√£o -->
<div id="connectionStatus" class="connection-status disconnected">üî¥ Offline</div>

<!-- Tela de Boas-Vindas -->
<div id="welcomeScreen" class="screen">
  <h1>üéâ Cabine Fotogr√°fica</h1>
  <h2>Bem-vindo!</h2>
  <button id="enterFullscreen">üöÄ ENTRAR EM TELA CHEIA</button>
  <button id="skipFullscreen" style="background: transparent; color: white; border: 2px solid white;">‚è≠Ô∏è PULAR TELA CHEIA</button>
</div>

<!-- Tela de In√≠cio -->
<div id="startScreen" class="screen">
  <h1>üì∏ Cabine Fotogr√°fica</h1>
  <h2>Prepare-se para a divers√£o!</h2>
  <button id="startSession">üé¨ CLIQUE AQUI PARA COME√áAR</button>
</div>

<!-- Tela da C√¢mera -->
<div id="cameraScreen" class="screen">
  <video id="preview" autoplay playsinline></video>
  <div id="countdown"></div>
  <div id="photoCounter"></div>
</div>

<!-- Tela de Resultado -->
<div id="resultScreen" class="screen">
  <h1>üéâ Sua Foto Pronta!</h1>
  <img id="finalImage" src="" alt="Foto Montada">
  <div class="thankYou">Obrigado! ü•∞</div>
</div>

<canvas id="canvas"></canvas>
<canvas id="montageCanvas"></canvas>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
// Elementos
const welcomeScreen = document.getElementById('welcomeScreen');
const startScreen = document.getElementById('startScreen');
const cameraScreen = document.getElementById('cameraScreen');
const resultScreen = document.getElementById('resultScreen');
const video = document.getElementById('preview');
const canvas = document.getElementById('canvas');
const montageCanvas = document.getElementById('montageCanvas');
const countdownEl = document.getElementById('countdown');
const photoCounterEl = document.getElementById('photoCounter');
const finalImageEl = document.getElementById('finalImage');
const enterFullscreenBtn = document.getElementById('enterFullscreen');
const skipFullscreenBtn = document.getElementById('skipFullscreen');
const startSessionBtn = document.getElementById('startSession');
const connectionStatus = document.getElementById('connectionStatus');

const ctx = canvas.getContext('2d');
const montageCtx = montageCanvas.getContext('2d');

// Configura√ß√µes
const session = new URLSearchParams(window.location.search).get("session");
const socketURL = new URLSearchParams(window.location.search).get("socket");

// Configura√ß√£o robusta do Socket.io
let socket = io(socketURL, {
  transports: ['websocket', 'polling'],
  reconnection: true,
  reconnectionAttempts: 10,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  timeout: 20000
});

let localStream;
let photos = [];
let templateImage = new Image();
let templateLoaded = false;
let isConnected = false;

// COORDENADAS REAIS do image-map.net (3375x6000)
const photoAreas = [
  { 
    number: 1, 
    x: 149, 
    y: 576, 
    width: 2374,
    height: 1540
  },
  { 
    number: 2, 
    x: 146, 
    y: 3888, 
    width: 2374,
    height: 1541
  },
  { 
    number: 3, 
    x: 156, 
    y: 2225, 
    width: 2367,
    height: 1544
  }
];

// Tenta carregar o template
templateImage.src = "caralho.png";
templateImage.onload = () => {
  console.log("‚úÖ Template carregado com sucesso");
  templateLoaded = true;
};
templateImage.onerror = () => {
  console.log("‚ö†Ô∏è Template n√£o encontrado, usando fallback");
  templateLoaded = false;
  createFallbackTemplate();
};

function createFallbackTemplate() {
  const fallbackCanvas = document.createElement('canvas');
  fallbackCanvas.width = 3375;
  fallbackCanvas.height = 6000;
  const fallbackCtx = fallbackCanvas.getContext('2d');
  
  // Fundo
  const gradient = fallbackCtx.createLinearGradient(0, 0, 3375, 6000);
  gradient.addColorStop(0, '#667eea');
  gradient.addColorStop(1, '#764ba2');
  fallbackCtx.fillStyle = gradient;
  fallbackCtx.fillRect(0, 0, 3375, 6000);
  
  // T√≠tulo
  fallbackCtx.fillStyle = 'white';
  fallbackCtx.font = 'bold 120px Arial';
  fallbackCtx.textAlign = 'center';
  fallbackCtx.fillText('üì∏ CABINE FOTOGR√ÅFICA', 3375/2, 500);
  
  templateImage.src = fallbackCanvas.toDataURL();
  templateLoaded = true;
}

// Mostra tela inicial
window.addEventListener('load', () => {
  welcomeScreen.style.display = 'flex';
});

// Entrar em tela cheia - CORRIGIDO
enterFullscreenBtn.addEventListener('click', () => {
  try {
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen()
        .then(() => {
          console.log('‚úÖ Entrou em tela cheia');
          goToStartScreen();
        })
        .catch(error => {
          console.log('‚ùå Fullscreen n√£o permitido, continuando...');
          goToStartScreen();
        });
    } else {
      goToStartScreen();
    }
  } catch (error) {
    console.log('‚ùå Erro fullscreen, continuando...');
    goToStartScreen();
  }
});

// Pular tela cheia
skipFullscreenBtn.addEventListener('click', goToStartScreen);

function goToStartScreen() {
  welcomeScreen.style.display = 'none';
  startScreen.style.display = 'flex';
}

// Iniciar sess√£o
startSessionBtn.addEventListener('click', startPhotoSession);

async function startPhotoSession() {
  try {
    startScreen.style.display = 'none';
    cameraScreen.style.display = 'flex';
    
    // Inicializa c√¢mera
    if (!localStream) {
      localStream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user" }, 
        audio: false 
      });
      video.srcObject = localStream;
    }
    
    // Inicia sequ√™ncia de fotos
    await takePhotoSequence();
    
  } catch (error) {
    console.error('Erro na sess√£o:', error);
    showError('Erro ao acessar a c√¢mera');
  }
}

// === FUN√á√ÉO takePhotoSequence CORRIGIDA PARA O FLUXO SOLICITADO ===
async function takePhotoSequence() {
  photos = [];

  const freezeDiv = document.getElementById('freezePreview');
  const freezeImg = document.getElementById('freezeImg');

  for (let i = 1; i <= 3; i++) {
    photoCounterEl.textContent = `Foto ${i} de 3`;

    // Contagem regressiva: mostra 5..2 (1s cada). Em seguida mostra "SORRIA üì∏", toca o √°udio e espera 2s.
    await countdown(5);

    // Captura foto (preenche photos[i])
    await takePhoto(i);

    // Mostra a foto congelada por 3 segundos
    try {
      if (photos[i]) {
        if (freezeImg) freezeImg.src = photos[i];
        if (freezeDiv) freezeDiv.style.display = 'flex';
        await delay(3000);
        if (freezeDiv) freezeDiv.style.display = 'none';
      }
    } catch (err) {
      console.warn('Erro ao exibir foto congelada:', err);
    }

    // Opcional: upload individual
    try {
      if (typeof uploadPhotoToImgBB === 'function') {
        const uploaded = await uploadPhotoToImgBB(photos[i]);
        photosImgBBUrls[i] = uploaded;
      }
    } catch (err) {
      console.warn('Erro upload foto', i, err);
    }

    if (i < 3) {
      // Curto intervalo antes da pr√≥xima contagem para estabilizar
      await delay(500);
    }
  }

  // Depois de capturar 3 fotos, cria montagem final (se existir fun√ß√£o)
  try {
    if (typeof createMontage === 'function') {
      await createMontage();
    } else if (typeof createFinalMontage === 'function') {
      await createFinalMontage();
    } else {
      console.warn('createMontage n√£o encontrada - finalize remotamente.');
    }
  } catch (err) {
    console.error('Erro criando montagem:', err);
  }
}


function countdown(seconds) {
  // Countdown: show numbers from `seconds` down to 2, then show "SORRIA üì∏", play sound and wait 2s.
  return new Promise(async (resolve) => {
    try {
      const el = document.getElementById('countdown');
      if (!el) return resolve();
      el.classList.remove('hidden');
      // show numeric countdown for seconds..2
      for (let n = seconds; n >= 2; n--) {
        el.textContent = String(n);
        el.style.fontSize = (Math.max(48, Math.floor(window.innerWidth / 6))) + 'px';
        await delay(1000);
      }
      // show SORRIA and play audio, wait 2 seconds
      el.textContent = 'SORRIA üì∏';
      el.style.fontSize = (Math.max(48, Math.floor(window.innerWidth / 8))) + 'px';
      el.style.fontWeight = '900';
      
      // play shutter sound exactly on SORRIA
      try {
        const shutter = document.getElementById('shutterAudio') || new Audio('clack.mp3');
        if (shutter && shutter.play) {
          shutter.currentTime = 0;
          await shutter.play().catch(()=>{});
        }
      } catch (playErr) {
        console.warn('Erro ao tocar √°udio no countdown:', playErr);
      }
      
      await delay(2000);
      el.classList.add('hidden');
      resolve();
    } catch (err) {
      console.error('Erro no countdown:', err);
      resolve();
    }
  });
}


async function takePhoto(index) {
  return new Promise((resolve) => {
    setTimeout(() => {
      try {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        const dataURL = canvas.toDataURL('image/png');
        photos[index] = dataURL;
        console.log(`‚úÖ Foto ${index} capturada`);
      } catch (error) {
        console.error('Erro ao capturar foto:', error);
      }
      resolve();
    }, 100);
  });
}

async function createFinalMontage() {
  return new Promise((resolve) => {
    const checkTemplate = () => {
      if (templateLoaded) {
        // Tamanho do template VERTICAL 3375x6000
        montageCanvas.width = 3375;
        montageCanvas.height = 6000;
        
        // Limpa e desenha template
        montageCtx.clearRect(0, 0, montageCanvas.width, montageCanvas.height);
        montageCtx.drawImage(templateImage, 0, 0, montageCanvas.width, montageCanvas.height);
        
        let loadedPhotos = 0;
        const totalPhotos = 3;
        
        // Desenha cada foto na posi√ß√£o correta
        photoAreas.forEach(area => {
          if (photos[area.number]) {
            const img = new Image();
            img.onload = () => {
              try {
                // Desenha a foto redimensionada para caber na √°rea
                montageCtx.drawImage(img, area.x, area.y, area.width, area.height);
                console.log(`‚úÖ Foto ${area.number} posicionada em x:${area.x}, y:${area.y}`);
              } catch (error) {
                console.error(`Erro ao desenhar foto ${area.number}:`, error);
              }
              
              loadedPhotos++;
              if (loadedPhotos === totalPhotos) {
                finalizeMontage();
                resolve();
              }
            };
            img.onerror = () => {
              console.error(`Erro ao carregar foto ${area.number}`);
              loadedPhotos++;
              if (loadedPhotos === totalPhotos) {
                finalizeMontage();
                resolve();
              }
            };
            img.src = photos[area.number];
          } else {
            // Se a foto n√£o existe, ainda incrementa contador para n√£o travar
            loadedPhotos++;
            if (loadedPhotos === totalPhotos) {
              finalizeMontage();
              resolve();
            }
          }
        });
      } else {
        setTimeout(checkTemplate, 100);
      }
    };
    
    function finalizeMontage() {
      try {
        const finalDataURL = montageCanvas.toDataURL('image/png');
        finalImageEl.src = finalDataURL;
        
        // ENVIA PARA O PC - CORRIGIDO
        console.log("üì§ Enviando foto para PC...");
        
        const photoData = {
          session: session,
          finalImage: finalDataURL,
          timestamp: Date.now()
        };
        
        // Verifica se est√° conectado antes de enviar
        if (isConnected && socket.connected) {
          // Envia m√∫ltiplas vezes para garantir
          socket.emit("final_photo", photoData);
          setTimeout(() => socket.emit("final_photo", photoData), 500);
          setTimeout(() => socket.emit("finalPhoto", photoData), 1000);
          
          console.log("‚úÖ Foto enviada para PC (m√∫ltiplas tentativas)");
        } else {
          console.error("‚ùå N√£o conectado ao servidor, n√£o foi poss√≠vel enviar foto");
          showError("Erro de conex√£o - Foto n√£o enviada");
        }
        
      } catch (error) {
        console.error("‚ùå Erro ao enviar para PC:", error);
      }
    }
    
    checkTemplate();
  });
}

// alias para compatibilidade: createMontage()
async function createMontage() {
  return await createFinalMontage();
}

function showResult() {
  cameraScreen.style.display = 'none';
  resultScreen.style.display = 'flex';
  
  // Ap√≥s 10 segundos, mostra apenas "obrigado" (oculta t√≠tulo e imagem)
  setTimeout(() => {
    document.querySelector('#resultScreen h1').style.display = 'none';
    finalImageEl.style.display = 'none';
    // Mantemos .thankYou vis√≠vel at√© o operador finalizar sess√£o no PC
  }, 10000);
}

function showError(message) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error';
  errorDiv.textContent = message;
  document.body.appendChild(errorDiv);
  
  setTimeout(() => {
    errorDiv.remove();
    startScreen.style.display = 'flex';
    cameraScreen.style.display = 'none';
  }, 5000);
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Socket events - CORRIGIDOS E ROBUSTOS
socket.on('connect', () => {
  console.log('‚úÖ Conectado ao servidor Socket.io');
  isConnected = true;
  connectionStatus.textContent = 'üü¢ Online';
  connectionStatus.className = 'connection-status connected';
  
  // Entra na sala da sess√£o
  socket.emit('join_room', { session: session });
});

socket.on('disconnect', (reason) => {
  console.log('‚ùå Desconectado do servidor:', reason);
  isConnected = false;
  connectionStatus.textContent = 'üî¥ Offline';
  connectionStatus.className = 'connection-status disconnected';
});

socket.on('connect_error', (error) => {
  console.log('‚ùå Erro de conex√£o:', error);
  isConnected = false;
  connectionStatus.textContent = 'üî¥ Erro Conex√£o';
  connectionStatus.className = 'connection-status disconnected';
});

socket.on('reconnect', (attemptNumber) => {
  console.log('üîÑ Reconectado ao servidor ap√≥s', attemptNumber, 'tentativas');
  isConnected = true;
  connectionStatus.textContent = 'üü¢ Online';
  connectionStatus.className = 'connection-status connected';
});

socket.on('reconnect_attempt', (attemptNumber) => {
  console.log('üîÑ Tentativa de reconex√£o:', attemptNumber);
  connectionStatus.textContent = 'üü° Reconectando...';
});

socket.on('restart_session', (data) => {
  console.log('üîÑ Recebido comando para reiniciar sess√£o');
  if (data.session === session) {
    restartSession();
  }
});

socket.on('restartSession', (data) => {
  console.log('üîÑ Recebido comando antigo para reiniciar');
  if (data.session === session) {
    restartSession();
  }
});

function restartSession() {
  console.log('üîÑ Reiniciando sess√£o...');
  resultScreen.style.display = 'none';
  startScreen.style.display = 'flex';
  
  // Reseta vari√°veis
  photos = [];
  finalImageEl.src = '';
}

// Previne sa√≠da do fullscreen
document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement) {
    try {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    } catch (error) {
      // Ignora erro
    }
  }
});

// Tentativa de reconex√£o manual
setInterval(() => {
  if (!isConnected && !socket.connected) {
    console.log('üîÑ Tentando reconectar manualmente...');
    socket.connect();
  }
}, 5000);
</script>
</body>
</html>
